"""ad-hoc RPC functionality"""from pathlib import Pathimport sysfrom typing import Literal, Any, Union, Callable, OptionalCallerSerializationType = Literal["json", "pickle", "text"]"""code for payload serialization method"""CallerCompressionType = Literal["gzip", None]"""code for payload compression method"""CallerUnpackingOperator = Literal["", "*", "**"]"""string representation of unpacking operator, if any, used to insert reconstructed payload into called function"""def to_heredoc(    heredoc_content: str,    addition: str = "",    identifier: str = "__BOUNDARYTAG__") -> str:    """    create a bash heredoc statement.    Args:        heredoc_content: content of the heredoc.        addition: optional additional statement between heredoc identifier            and body        identifier: heredoc delimiting identifier.    Returns:        bash heredoc statement.    """    return f"{identifier} {addition}\n{heredoc_content}\n{identifier}\n"def encode_payload(    obj: Any,    serialization: CallerSerializationType,    compression: CallerCompressionType) -> Union[str, bytes]:    """    encode the 'payload' of a remote procedure call.    Args:        obj: object to encode        serialization: serialization method for obj        compression: how to compress the serialized object (None means            uncompressed)    Returns:        string or bytes containing encoded payload.    """    if serialization == "json":        import json        serial = json.dumps(obj)    elif serialization == "pickle":        import pickle        serial = pickle.dumps(obj)    elif serialization is None:        serial = obj.__repr__()    else:        raise NotImplementedError    if _check_mode(serialization, compression) == "text":        if serialization == "json":            return f'"""{serial}"""'        return serial    if isinstance(serial, str):        serial = serial.encode("ascii")    if compression == "gzip":        import gzip        serial = gzip.compress(serial)    elif compression is not None:        raise NotImplementedError    import base64    return base64.b64encode(serial)def format_importer(module: Optional[str], func: str) -> str:    """    formatting function for import section of RPC script.    Args:        module: name of or path to module        func: name of function in module    Returns:        import source code block    """    importer = f"""if __name__ == "__main__":    """    if module is None:        importer += f"""target = {func}    """        return importer    if module.endswith(".py"):        importer += f"""import importlib.util    import sys    spec = importlib.util.spec_from_file_location(        "{Path(module).stem}", "{module}"    )    module = importlib.util.module_from_spec(spec)    sys.modules["{Path(module).stem}"] = module    spec.loader.exec_module(module)    """    else:        importer += f"""import {module}    module = {module}    """    if func is not None:        importer += f"""target = getattr(module, "{func}")    """    return importerdef format_decompressor(    serialized: Union[str, bytes],    serialization: CallerSerializationType,    compression: CallerCompressionType) -> str:    """    create decompression section of RPC script.    Args:        serialized: serialized payload        serialization: name of serialization method used        compression: name of compression method used    Returns:        decompression source code block    """    if _check_mode(serialization, compression) == "text":        return f"""payload = {serialized}    """    if compression is None:        return f"""import base64    payload = base64.b64decode({serialized})    """    if compression == "gzip":        return f"""import base64    import gzip    payload = gzip.decompress(base64.b64decode({serialized}))    """    raise NotImplementedError("only gzip compression is currently supported")def format_deserializer(serialization: CallerSerializationType) -> str:    """    create deserialization section of RPC script.    Args:        serialization: serialization method used    Returns:        deserialization source code block    """    if serialization is None:        return ""    if serialization == "json":        return f"import json\npayload = json.loads(payload)"    elif serialization == "pickle":        return f"import pickle\npayload = pickle.loads(payload)"    raise NotImplementedError("Unknown serializer. use 'json' or 'pickle'")def _check_reconstructable(    typeobj: type,    serialization: CallerSerializationType,    compression: CallerSerializationType):    """    Raise an error if we are attempting to transfer a compressed, unserialized    in-memory object with no stable binary representation, which is, for our    purposes, anything but a string.    Args:        typeobj: type of payload object        serialization: name of serialization method used        compression: name of compression method used    """    if (        (typeobj is not str)        and (compression is not None)        and (serialization is None)    ):        raise ValueError(            "non-string compressed objects will not reconstruct correctly "            "unless serialized. try compress='gzip', serialization='json' "            "or serialize='pickle'"        )def _check_mode(    serialization: CallerSerializationType, compression: CallerCompressionType) -> Literal["text", "binary"]:    """should we think of our output as in text or binary mode?"""    if (compression is None) and serialization in (None, "json"):        return "text"    return "binary"def format_kwarg_filter(    filter_kwargs: bool, splat: CallerUnpackingOperator) -> str:    """    generate kwarg filter section of RPC script, if necessary and requested    Args:        filter_kwargs: should we filter unwanted kwargs or not?        splat: unpacking operator we're using. if it's not '**',            never generate this block -- it's unnecessary.    Returns:        kwarg-filtering source code block.    """    if (filter_kwargs is not True) or (splat != "**"):        return ""    return """from inspect import getfullargspec    spec = getfullargspec(target)    payload = {        k: v for k, v in payload.items()         if k in spec.args + spec.kwonlyargs    }    """# TODO: validity check to make sure it compilesdef generic_python_endpoint(    module=None,    func=None,    payload=None,    compression=None,    serialization=None,    splat=None,    payload_encoded=False,    print_result=False,    filter_kwargs=False,    interpreter=None,    for_bash=True,):    """    dynamically construct a shell script that calls a python function with a    given 'payload'.    """    if (payload is not None) and (func is None):        raise ValueError("Must pass a function name to pass a payload.")    _check_reconstructable(type(payload), serialization, compression)    import_ = format_importer(module, func)    if func is None:        return import_    if payload_encoded is False:        payload = encode_payload(payload, serialization, compression)    elif payload is not None:        payload.__repr__()    else:        payload = ""    decompress = format_decompressor(payload, serialization, compression)    deserialize = format_deserializer(serialization)    if splat is None:        splat = ""    kwarg_filter = format_kwarg_filter(filter_kwargs, splat)    call = f"target({splat}payload)"    if print_result is True:        call = f"print({call})"    endpoint = import_ + decompress + deserialize + kwarg_filter + call    if for_bash is True:        if interpreter is None:            interpreter = sys.executable        return f"{interpreter} <<{to_heredoc(endpoint)}"    return endpointdef python_endpoint_factory(    module: str, **endpoint_kwargs) -> Callable[[Any], str]:    """    creates a function that generates shell scripts to call Python functions    from a particular module.    """    if "payload" in endpoint_kwargs.keys():        raise ValueError("cannot bake a payload into the endpoint factory")    def load_payload(payload):        return generic_python_endpoint(            module, payload=payload, **endpoint_kwargs        )    return load_payload